Django is a high-level Python web framework that helps developers build secure, scalable, and maintainable web applications quickly. Here are the basics you need to know:

âœ… 1. What is Django?

Django is an open-source web framework based on Python.
It follows the MVT (Model-View-Template) architecture.
Designed for rapid development and clean, pragmatic design.


âœ… 2. Key Features

ORM (Object-Relational Mapping): Interact with databases using Python instead of SQL.
Built-in Admin Panel: Auto-generated interface for managing data.
Security: Protects against common attacks like SQL injection, CSRF, XSS.
Scalability: Used by big companies like Instagram, Pinterest.
DRY Principle: â€œDonâ€™t Repeat Yourselfâ€ â€“ encourages reusable code.


âœ… 3. Django Architecture (MVT)

Model: Handles database (tables, queries).
View: Business logic (Python functions/classes).
Template: HTML/CSS for UI.


âœ… 4. Basic Workflow

Install Django:
pip install django

Create a Project:
django-admin startproject myproject

Run Server:
python manage.py runserver

Create an App:
python manage.py startapp myapp

Define Models: (in models.py)
from django.db import models
class Student(models.Model):
  name = models.CharField(max_length=100)
  age = models.IntegerField()

Apply Migrations:
python manage.py makemigrations
python manage.py migrate

Create Views & Templates: (in views.py and templates/ folder)
Map URLs: (in urls.py)
=========================================================================================================================================================
ASGI And WSGI

In Django, both asgi.py and wsgi.py are entry points for running your application, 
but they serve different purposes depending on whether your app is asynchronous or synchronous.

1. WSGI (Web Server Gateway Interface)

File: wsgi.py
Purpose: Standard interface between synchronous Python web apps and web servers.
Nature: Synchronous â€” handles one request at a time per worker/thread.
Concurrency: Achieved via multiple processes or threads.
Use Case: Traditional Django apps without async features.
Server Examples: Gunicorn, uWSGI, mod_wsgi (Apache).

Example (wsgi.py):
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
application = get_wsgi_application()


2. ASGI (Asynchronous Server Gateway Interface)

File: asgi.py
Purpose: Standard interface for asynchronous Python web apps and servers.
Nature: Asynchronous + Synchronous â€” can handle both types of requests.
Concurrency: Handles multiple requests concurrently without blocking.
Use Case: Real-time features (WebSockets, long polling, async views).
Server Examples: Uvicorn, Daphne, Hypercorn.

Example (asgi.py):
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
application = get_asgi_application()
---------------------------------------------------------------------------------------------------------------------

1. makemigrations

Purpose: Detects changes in your models.py and creates migration files (Python scripts) that describe those changes.
What it does:

Compares your current models with the last applied migration.
Generates migration files inside the migrations/ folder of each app.
These files contain instructions for how to modify the database schema (e.g., create tables, add/remove fields).

When to use:
After you change your models (add a field, delete a model, rename a field, etc.).
Example:Bashpython manage.py makemigrations

Output might be:Migrations for 'blog':
  blog/migrations/0002_post_created_at.py
    - Add field created_at to post

2. migrate

Purpose: Applies (or unapplies) migration files to the actual database.
What it does:

Reads migration files.
Executes the SQL commands needed to update the database schema.
Keeps track of applied migrations in the django_migrations table.

When to use:
After running makemigrations (or when pulling migrations from another developer).
Example:Bashpython manage.py migrate

Output might be:Applying blog.0002_post_created_at... OK

Key Difference Table

Command
Function
Affects Database?
Typical Usage Order

makemigrations
Creates migration files from model changes
âŒ No
First

migrate
Applies migration files to the database
âœ… Yes
Second

ðŸ’¡ In short:

makemigrations â†’ "Prepare the migration plan" (writes Python migration scripts).
migrate â†’ "Execute the migration plan" (updates the database).

---------------------------------------------------------------------------------------------------------------------

there are two major tags in our migration :- 
Dependiencies - are the dependencies on previous migrations
and Operations - what are the operations our migration is duing

==================================================================================================================

CRUD operations in Django 

(Create, Read, Update, Delete) are fundamental techniques for managing persistent data using Djangoâ€™s Object-Relational Mapper (ORM). 
These operations can be implemented using Django Models, ModelForms, and views (either Function-Based Views or Class-Based Views) to interact with databases.  
Core Components : -

â€¢ Models (): Define the structure of the data. 
â€¢ Forms (): Handle user input, validation, and saving data. 
â€¢ Views (): Handle logic for processing data. 
â€¢ Templates (): User interface for displaying and submitting data. [1, 2, 3, 5, 6]  

1. Create (Insert Data) [7, 8]  
Data is created by instantiating a model class and calling  or by using a . 

â€¢ Using : save()
new_item = MyModel(field1="data", field2="more data")
new_item.save()

â€¢ Using : Modelform
if request.method == 'POST':
    form = MyModelForm(request.POST)
    if form.is_valid():
        form.save() # Saves to database


2. Read (Retrieve Data) 
Data is retrieved using the Model Manager (), which allows filtering, fetching all records, or finding a single record. 

â€¢ Retrieve All:  items = MyModel.objects.all()
â€¢ Filter Records:  items = MyModel.objects.filter(field1="data")
â€¢ Single Record:  item = MyModel.objects.get(id=1)

-> the difference b/w get and filter is if no object is found in get it will through an error where as in filter through empty list.

3. Update (Modify Data) 
Updating involves retrieving an existing record, modifying its attributes, and saving it back to the database. 
# views.py
item = MyModel.objects.get(id=1)
item.field1 = "Updated Data"
item.save()

4. Delete (Remove Data) 
Data is deleted by calling the  method on a retrieved model instance. 
# views.py
item = MyModel.objects.get(id=1)
item.delete()
======================================================================================================================
Basic Implementation Workflow :-
1 - Define Model: Create a model in app/models.py.
2 - Run Migrations: Execute python manage.py makemigrations and python manage.py migrate to create database tables.
3 - Create ModelForm: Create a forms.py using forms.ModelForm.
4 - Create Views: Write view functions in views.py to handle GET (display form/data) and POST (submit data) requests.
5 - Configure URLs: Add paths in urls.py for each operation.
6 - Build Templates: Create HTML templates for rendering forms and lists. 

========================================================================================================================
Alternative Methods
1 - Django Admin: Provides a built-in UI for CRUD without writing views.
2 - Class-Based Views (CBVs): Use ListView, DetailView, CreateView, UpdateView, and DeleteView for faster development.
3 - Django REST Framework (DRF): Used for performing CRUD via API endpoints. 
