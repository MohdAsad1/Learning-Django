Django is a high-level Python web framework that helps developers build secure, scalable, and maintainable web applications quickly. Here are the basics you need to know:

âœ… 1. What is Django?

Django is an open-source web framework based on Python.
It follows the MVT (Model-View-Template) architecture.
Designed for rapid development and clean, pragmatic design.


âœ… 2. Key Features

ORM (Object-Relational Mapping): Interact with databases using Python instead of SQL.
Built-in Admin Panel: Auto-generated interface for managing data.
Security: Protects against common attacks like SQL injection, CSRF, XSS.
Scalability: Used by big companies like Instagram, Pinterest.
DRY Principle: â€œDonâ€™t Repeat Yourselfâ€ â€“ encourages reusable code.


âœ… 3. Django Architecture (MVT)

Model: Handles database (tables, queries).
View: Business logic (Python functions/classes).
Template: HTML/CSS for UI.


âœ… 4. Basic Workflow

Install Django:
pip install django

Create a Project:
django-admin startproject myproject

Run Server:
python manage.py runserver

Create an App:
python manage.py startapp myapp

Define Models: (in models.py)
from django.db import models
class Student(models.Model):
  name = models.CharField(max_length=100)
  age = models.IntegerField()

Apply Migrations:
python manage.py makemigrations
python manage.py migrate

Create Views & Templates: (in views.py and templates/ folder)
Map URLs: (in urls.py)
=========================================================================================================================================================
ASGI And WSGI

In Django, both asgi.py and wsgi.py are entry points for running your application, 
but they serve different purposes depending on whether your app is asynchronous or synchronous.

1. WSGI (Web Server Gateway Interface)

File: wsgi.py
Purpose: Standard interface between synchronous Python web apps and web servers.
Nature: Synchronous â€” handles one request at a time per worker/thread.
Concurrency: Achieved via multiple processes or threads.
Use Case: Traditional Django apps without async features.
Server Examples: Gunicorn, uWSGI, mod_wsgi (Apache).

Example (wsgi.py):
import os
from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
application = get_wsgi_application()


2. ASGI (Asynchronous Server Gateway Interface)

File: asgi.py
Purpose: Standard interface for asynchronous Python web apps and servers.
Nature: Asynchronous + Synchronous â€” can handle both types of requests.
Concurrency: Handles multiple requests concurrently without blocking.
Use Case: Real-time features (WebSockets, long polling, async views).
Server Examples: Uvicorn, Daphne, Hypercorn.

Example (asgi.py):
import os
from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
application = get_asgi_application()
---------------------------------------------------------------------------------------------------------------------

1. makemigrations

Purpose: Detects changes in your models.py and creates migration files (Python scripts) that describe those changes.
What it does:

Compares your current models with the last applied migration.
Generates migration files inside the migrations/ folder of each app.
These files contain instructions for how to modify the database schema (e.g., create tables, add/remove fields).

When to use:
After you change your models (add a field, delete a model, rename a field, etc.).
Example:Bashpython manage.py makemigrations

Output might be:Migrations for 'blog':
  blog/migrations/0002_post_created_at.py
    - Add field created_at to post

2. migrate

Purpose: Applies (or unapplies) migration files to the actual database.
What it does:

Reads migration files.
Executes the SQL commands needed to update the database schema.
Keeps track of applied migrations in the django_migrations table.

When to use:
After running makemigrations (or when pulling migrations from another developer).
Example:Bashpython manage.py migrate

Output might be:Applying blog.0002_post_created_at... OK

Key Difference Table

Command
Function
Affects Database?
Typical Usage Order

makemigrations
Creates migration files from model changes
âŒ No
First

migrate
Applies migration files to the database
âœ… Yes
Second

ðŸ’¡ In short:

makemigrations â†’ "Prepare the migration plan" (writes Python migration scripts).
migrate â†’ "Execute the migration plan" (updates the database).

---------------------------------------------------------------------------------------------------------------------

there are two major tags in our migration :- 
Dependiencies - are the dependencies on previous migrations
and Operations - what are the operations our migration is duing

==================================================================================================================

CRUD operations in Django 

(Create, Read, Update, Delete) are fundamental techniques for managing persistent data using Djangoâ€™s Object-Relational Mapper (ORM). 
These operations can be implemented using Django Models, ModelForms, and views (either Function-Based Views or Class-Based Views) to interact with databases.  
Core Components : -

â€¢ Models (): Define the structure of the data. 
â€¢ Forms (): Handle user input, validation, and saving data. 
â€¢ Views (): Handle logic for processing data. 
â€¢ Templates (): User interface for displaying and submitting data. [1, 2, 3, 5, 6]  

1. Create (Insert Data) [7, 8]  
Data is created by instantiating a model class and calling  or by using a . 

â€¢ Using : save()
new_item = MyModel(field1="data", field2="more data")
new_item.save()

â€¢ Using : Modelform
if request.method == 'POST':
    form = MyModelForm(request.POST)
    if form.is_valid():
        form.save() # Saves to database


2. Read (Retrieve Data) 
Data is retrieved using the Model Manager (), which allows filtering, fetching all records, or finding a single record. 

â€¢ Retrieve All:  items = MyModel.objects.all()
â€¢ Filter Records:  items = MyModel.objects.filter(field1="data")
â€¢ Single Record:  item = MyModel.objects.get(id=1)

-> the difference b/w get and filter is if no object is found in get it will through an error where as in filter through empty queryset.

3. Update (Modify Data) 
Updating involves retrieving an existing record, modifying its attributes, and saving it back to the database. 
# views.py
item = MyModel.objects.get(id=1)
item.field1 = "Updated Data"
item.save()

OR 

item = MyMdel.objects.get(id =1).update(field1 = "Updated Data")

4. Delete (Remove Data) 
Data is deleted by calling the  method on a retrieved model instance. 
# views.py
item = MyModel.objects.get(id=1)
item.delete()
======================================================================================================================
Basic Implementation Workflow :-
1 - Define Model: Create a model in app/models.py.
2 - Run Migrations: Execute python manage.py makemigrations and python manage.py migrate to create database tables.
3 - Create ModelForm: Create a forms.py using forms.ModelForm.
4 - Create Views: Write view functions in views.py to handle GET (display form/data) and POST (submit data) requests.
5 - Configure URLs: Add paths in urls.py for each operation.
6 - Build Templates: Create HTML templates for rendering forms and lists. 

========================================================================================================================
Alternative Methods
1 - Django Admin: Provides a built-in UI for CRUD without writing views.
2 - Class-Based Views (CBVs): Use ListView, DetailView, CreateView, UpdateView, and DeleteView for faster development.
3 - Django REST Framework (DRF): Used for performing CRUD via API endpoints. 

========================================================================================================================
__icontains  -> will check if the given value is present in queryset
========================================================================================================================
Authentication in web requestsÂ¶
Django uses sessions and middleware to hook the authentication system into request objects.

These provide a request.user attribute and a request.auser async method on every request which represents the current user.
If the current user has not logged in, this attribute will be set to an instance of AnonymousUser, otherwise it will be an instance of User.
if request.user.is_authenticated:
    # Do something for authenticated users.
    ...
else:
    # Do something for anonymous users.
    ...

==========================================================================================================================
The login_required decoratorÂ¶
login_required(redirect_field_name='next', login_url=None)[source]Â¶
As a shortcut, you can use the convenient login_required() decorator:

from django.contrib.auth.decorators import login_required


@login_required
def my_view(request): ...

===========================================================================================================================
Django User Model

Djangoâ€™s User model is the core of its authentication system, storing essential user information and permissions. 
By default, itâ€™s provided via django.contrib.auth.models.User, but Django also supports custom user models for flexibility.

from django.contrib.auth.models import User
class Profile(models.Model):
user = models.ForeignKey(User, on_delete=models.CASCADE)

==========================================================================================================================
Custom User Model
If you need extra fields (e.g., phone number, profile picture), you should create a custom user model using AbstractUser or AbstractBaseUser.

Example with AbstractUser:

from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    profile_picture = models.ImageField(upload_to='profiles/', blank=True, null=True)

    def __str__(self):
        return self.username

==========================================================================================================================
queryset = Model.objects.all().order_by(value)[0:200]

it will give the first 200 va;ue in the soted accending order, if i want decending -->  order_by(-value)
=========================================================================================================================
queryset = Model.objects.all().order_by(value__gte = 50)[0:200]

give the queryset whose value is greterthen 50 - use __lte for lower then 
=========================================================================================================================
ForeignKey in Django
used to define a many-to-one relationship between two models. 
It allows multiple instances of one model to be associated with a single instance of another model, such as linking comments to a blog post or orders to a customer.

from django.db import models

class Post(models.Model):
title = models.CharField(max_length=200)
content = models.TextField()
published_at = models.DateTimeField(auto_now_add=True)

def __str__(self):
return self.title

class Comment(models.Model):
post = models.ForeignKey(Post, on_delete=models.CASCADE) # ForeignKey relationship
author = models.CharField(max_length=100)
text = models.TextField()
created_at = models.DateTimeField(auto_now_add=True)

def __str__(self):
return f"Comment by {self.author}"
==============================================================================================================================
select_related() is a QuerySet method used to optimize database queries by performing a SQL JOIN and fetching related objects in a single query instead of multiple queries.
It is mainly used for ForeignKey and OneToOneField relationships.

Normally, when you access a related object, Django performs a lazy lookup (extra query).
With select_related(), Django fetches the related object at the same time as the main object.

Example Without select_related()
# models.py
from django.db import models

class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# views.py
books = Book.objects.all()
for book in books:
    print(book.title, book.author.name)  # Causes N+1 queries
Problem:

1 query to get all books
1 query per book to get its author â†’ N+1 queries (slow for large datasets)
Example With select_related()
books = Book.objects.select_related('author').all()
for book in books:
    print(book.title, book.author.name)  # Only 1 query
Benefit:

Single SQL query with a JOIN to fetch books and authors together.
Multiple Relationships
Python

Copy code
books = Book.objects.select_related('author__profile').all()
This will join across multiple related models.

When to Use
âœ… Use select_related() for:

ForeignKey
OneToOneField
When you know you'll need related object data immediately.
=========================================================================================================================
select_related VS prefetch_related 
both are queryset optimization methods used to reduce the N+1 query problem when accessing related objects â€” but they work differently.

1. select_related
Purpose: Optimizes single-valued relationships (ForeignKey, OneToOneField).
How it works: Uses SQL JOIN to fetch related objects in the same query.
When to use: When you know you'll need related object data for each row and the relationship is one-to-one or many-to-one.
Pros:
Only one SQL query.
Faster for single-valued relationships.
Cons:
Can fetch more data than needed if related tables are large.
Not suitable for reverse/many-to-many relationships.
Example:

Python

Copy code
# models.py
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# views.py
books = Book.objects.select_related('author')  # Single JOIN query
for book in books:
    print(book.title, book.author.name)
SQL generated:
SELECT book.id, book.title, author.id, author.name
FROM book
INNER JOIN author ON book.author_id = author.id;

2. prefetch_related
Purpose: Optimizes multi-valued relationships (ManyToManyField, reverse ForeignKey).
How it works: Runs two separate queries â€” one for the main model, one for related objects â€” and joins them in Python.
When to use: When you need to fetch lists of related objects for each main object.
Pros:
Efficient for many-to-many or reverse relationships.
Avoids huge JOINs.
Cons:
Two queries instead of one (but still much faster than N+1 queries).
Example:

# models.py
class Author(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.ForeignKey(Author, on_delete=models.CASCADE)

# views.py
authors = Author.objects.prefetch_related('book_set')  # Two queries
for author in authors:
    print(author.name, [book.title for book in author.book_set.all()])
SQL generated:

Sql

Copy code
-- First query
SELECT id, name FROM author;

-- Second query
SELECT id, title, author_id FROM book
WHERE author_id IN (list_of_author_ids);
Key Differences Table
Feature	select_related	prefetch_related
Relationship type	Single-valued (FK, OneToOne)	Multi-valued (M2M, reverse FK)
SQL queries	1 (JOIN)	2+ (batched)
Data join location	Database	Python
Best for	Single related object per row	Multiple related objects per row
âœ… Rule of Thumb:

Use select_related for ForeignKey / OneToOne (forward lookups).
Use prefetch_related for ManyToMany / reverse ForeignKey (backward lookups).
You can combine them for complex queries:
Python

Copy code
Book.objects.select_related('author').prefetch_related('categories')
==========================================================================================================
Django Q | 
Q objects are used to build complex queries with OR, AND, and NOT conditions that go beyond the default .filter() chaining (which uses implicit AND).

from django.db.models import Q
# Products that are either in 'Electronics' category OR priced below 500
products = Product.objects.filter(
    Q(category='Electronics') | Q(price__lt=500)

