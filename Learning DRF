Django REST Framework (DRF) :- 
A powerful toolkit and the de facto standard for building RESTful APIs with the Django web framework. 
It seamlessly integrates with Django's core features to convert complex data like Django models into formats like JSON or XML 
that can be used by modern frontends, mobile apps, or other services. 

[Core Concepts]
DRF development revolves around several key components:

1 - Serializers: These act like Django Forms but for API data. 
They are responsible for converting complex data types (like Django model instances and querysets) into native Python datatypes 
that can be easily rendered into JSON or other content types. 
Serializers also handle incoming data deserialization and validation.

2 -Views and ViewSets: Views handle the incoming HTTP requests and return the HTTP responses, but unlike traditional Django views that render HTML templates, DRF views 
 return data (usually JSON).
A - APIView is the basic class that extends Django's View class, providing functionality for handling authentication and permissions.
B- GenericAPIView and its subclasses (e.g., ListCreateAPIView) provide ready-made solutions for common use cases like listing and creating objects.
C - ViewSet abstracts logic even further by combining related views for standard CRUD operations (list, create, retrieve, update, destroy) 
into a single class, minimizing code repetition.

3 - Routers: When using ViewSet classes, DRF routers (DefaultRouter or SimpleRouter) automatically generate standardized URL patterns for the various actions, 
eliminating the need to manually define each URL path.

4 - Authentication and Permissions: DRF provides a flexible, built-in system to secure your API.
A - Authentication identifies the user making the request (e.g., using sessions, tokens, or OAuth).
B - Permissions determine if the identified user has the necessary access to perform the requested action (e.g., only allowing an object's owner to delete it).

5 - Browsable API: A major usability feature of DRF is the interactive, web-browsable API interface. 
It allows developers to interact with the API endpoints directly in a web browser, making testing and debugging significantly easier. 

==========================================================================================================================================================

Basic Development Flow of a DRF Project

1 - Install Django and Django REST Framework using pip install djangorestframework.
2 - Add 'rest_framework' and your app to the INSTALLED_APPS in your Django project's settings.py file.
3 - Define your data models in models.py and run migrations.
4 - Create a serializers.py file in your app to define how model instances are converted to JSON and back.
5 - Define a ViewSet in views.py to handle API requests and link it to your serializer.
6 - Configure URL routing, typically using a router.register() call in your project's urls.py file to automatically map the ViewSet actions to URL endpoints. 
===============================================================================================================
GET - Read - Show all books / Show book 10
POST - Create - Add new book
PUT - Update (full) - Replace book 10 completely
PATCH - Update (partial) - Change just book’s title
DELETE - Delete - Remove book 10
==================================================================================================================
API View
There are various types of api viewsets 

1 - Function-Based Views with @api_view
Quick and simple for small endpoints.

# views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

@api_view(['GET', 'POST'])
def ping(request):
    if request.method == 'GET':
        return Response({'message': 'pong'})
    elif request.method == 'POST':
        data = request.data
        return Response({'received': data}, status=status.HTTP_201_CREATED)
-----------------------------------------------------------------------------------------------
Class-Based Views with APIView
Full control over the request/response cycle. You write HTTP method handlers (get, post, etc.).

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions

class HelloView(APIView):
    permission_classes = [permissions.AllowAny]  # or IsAuthenticated

    def get(self, request):
        user = request.user if request.user.is_authenticated else 'anonymous'
        return Response({'hello': str(user)})

    def post(self, request):
        payload = request.data
        return Response({'you_sent': payload}, status=status.HTTP_201_CREATED)
------------------------------------------------------------------------------------------------

Generic Class-Based Views (ListCreateAPIView, RetrieveUpdateDestroyAPIView, etc.)
Faster CRUD with common behaviors built in.

# serializers.py
from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'

# Views.py
class PersonAPI(APIView):
 def get(self, request):
  objs = Person.objects.filter(color_isnull = False)
  serializer = PeopleSerializer(objs, many = True )
  return Response(serializer.data)

 def post (self, request):
  data = request.data
  serializer - PeopleSerializer(data - data)
  if serializer.is_valid():
   serializer.save()
   return Response(serializer.data)
  return Response(serializer.errors)

def put (self, request):
  data = request.data
  serializer = Peopleserializer(data = data)
  if serializer.is_valid():
   return Response(serializer.data)
``
-----------------------------------------------------------------------------------------
Doing the CRUD with Generic(less Code)

from rest_framework import generics, permissions
from .models import Book
from .serializers import BookSerializer

class BookListCreateGeneric(generics.ListCreateAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [permissions.IsAuthenticated]

class BookDetailGeneric(generics.RetrieveUpdateDestroyAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [permissions.IsAuthenticated]
``
======================================================================================================
Model Serializer 
ModelSerializer is a shortcut class that automatically creates a serializer based on a Django model.
✅ Auto-generates fields from your model
✅ Built-in validation based on model field types, unique, max_length, blank, etc.
✅ Auto-implements create() and update() (you can override)
✅ Supports nested serializers, validators, read-only/write-only fields, and relationships

we can apply validations in model serializers
class BookSerializer(serializers.ModelSerializer):

    class Meta:
        model = Book
        fields = ['id', 'title', 'title_upper', 'author', 'published']

    def get_title_upper(self, obj):
        return obj.title.upper()
=======================================================================================================
Q - How to serialize the forigne key data in DRF????

1 - Depth keyword 
is used in serializers where we want to show the value of the secound model 
which is connected using the forign Key

2 - Another serializer
or we can get the data of secound serializer using another serializer and using in another serializer

class ColorSerializer(serializers.ModelSerializer):
 Class Meta:
  model = Color
  field = ['color_name']

class
PeopleSerializer(serializers.ModelSerializer):
 color = ColorSerializer (many = True)
 class Meta:
  model = Person
  fields = '_all_'
  # depth = 1
-------------------------------------------------------------------------------
we got full control while using secound serializer, 
wahile in depth we got all the fields of the secound serializer
=====================================================================================================

SerializerMethodField :-
A read-only field that calculates its value by calling a method on the serializer class. 
It is primarily used to add custom or derived data to your API response that isn't directly available as a model field. 

from rest_framework import serializers

class UserSerializer(serializers.ModelSerializer):
    # 1. Define the field
    full_name = serializers.SerializerMethodField()

    class Meta:
        model = User
        fields = ['id', 'username', 'full_name']

    # 2. Implement the get_<field_name> method
    def get_full_name(self, obj):
        return f"{obj.first_name} {obj.last_name}"

=================================================================================================
ModelViewSet :- 
ModelViewSet is a high-level class that gives you a complete set of CRUD endpoints (Create, Read, Update, Delete) for a 
Django model in one place

It combines the behavior of these mixins:
ListModelMixin → GET /items/
RetrieveModelMixin → GET /items/{id}/
CreateModelMixin → POST /items/
UpdateModelMixin → PUT/PATCH /items/{id}/
DestroyModelMixin → DELETE /items/{id}/


from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = "__all__"


from rest_framework.filters import SearchFilter, OrderingFilter
from django_filters.rest_framework import DjangoFilterBackend

class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [IsAuthenticated]

    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]
    filterset_fields = ["author"]
    search_fields = ["title", "author"]
    ordering_fields = ["created_at", "title"]
    ordering = ["-created_at"]
``
======================================================================================================
Token Authentication
In Django REST Framework (DRF) Token Authentication is a simple, built-in way to authenticate API requests using 
a static token per user.  The client sends the token in the Authorization header, and DRF uses it to identify the user.

✅ Best for: internal APIs, quick prototypes, or simple client-server apps
⚠️ Not ideal for: high-security/public APIs (consider JWT/OAuth2 instead)


from rest_framework.views import APIView
from rest_framework.response import Responce
from rest_framework.permissions import IsAuthenticated
from rest_framework.authentication import TokenAuthentication

class ProfileView(APIView):
    authentication_classes = [TokenAuthentication]
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({"user": request.user.username})

TokenAuthentication in DRF is static:

Tokens don’t expire by default
If leaked, attacker can use it until revoked
Rotating tokens requires custom logic

✅ Best Practices

Use HTTPS always
Implement token rotation (custom)
Consider JWT (short-lived access tokens + refresh tokens) for public APIs
Store tokens securely in clients (avoid localStorage if possible in browsers)

-------------------------------------------------------------------------------------------
Django Actions

DRF, “Actions” usually means custom endpoints you add to a ViewSet using @action. 
They let you create routes beyond the standard CRUD (list/retrieve/create/update/destroy)—for example: POST /users/{id}/reset_password/ or GET /orders/recent/.


from rest_framework.permissions import IsAuthenticated, IsAdminUser

class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()
    serializer_class = BookSerializer

    @action(detail=False, methods=["get"], permission_classes=[IsAuthenticated])
    def my_books(self, request):
        qs = Book.objects.filter(owner=request.user)
        return Response(self.get_serializer(qs, many=True).data)

    @action(detail=True, methods=["delete"], permission_classes=[IsAdminUser])
    def hard_delete(self, request, pk=None):
        book = self.get_object()
        book.delete()
        return Response(status=204)

