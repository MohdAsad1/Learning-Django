Django REST Framework (DRF) :- 
A powerful toolkit and the de facto standard for building RESTful APIs with the Django web framework. 
It seamlessly integrates with Django's core features to convert complex data like Django models into formats like JSON or XML 
that can be used by modern frontends, mobile apps, or other services. 

[Core Concepts]
DRF development revolves around several key components:

1 - Serializers: These act like Django Forms but for API data. 
They are responsible for converting complex data types (like Django model instances and querysets) into native Python datatypes 
that can be easily rendered into JSON or other content types. 
Serializers also handle incoming data deserialization and validation.

2 -Views and ViewSets: Views handle the incoming HTTP requests and return the HTTP responses, but unlike traditional Django views that render HTML templates, DRF views 
 return data (usually JSON).
A - APIView is the basic class that extends Django's View class, providing functionality for handling authentication and permissions.
B- GenericAPIView and its subclasses (e.g., ListCreateAPIView) provide ready-made solutions for common use cases like listing and creating objects.
C - ViewSet abstracts logic even further by combining related views for standard CRUD operations (list, create, retrieve, update, destroy) 
into a single class, minimizing code repetition.

3 - Routers: When using ViewSet classes, DRF routers (DefaultRouter or SimpleRouter) automatically generate standardized URL patterns for the various actions, 
eliminating the need to manually define each URL path.

4 - Authentication and Permissions: DRF provides a flexible, built-in system to secure your API.
A - Authentication identifies the user making the request (e.g., using sessions, tokens, or OAuth).
B - Permissions determine if the identified user has the necessary access to perform the requested action (e.g., only allowing an object's owner to delete it).

5 - Browsable API: A major usability feature of DRF is the interactive, web-browsable API interface. 
It allows developers to interact with the API endpoints directly in a web browser, making testing and debugging significantly easier. 

==========================================================================================================================================================

Basic Development Flow of a DRF Project

1 - Install Django and Django REST Framework using pip install djangorestframework.
2 - Add 'rest_framework' and your app to the INSTALLED_APPS in your Django project's settings.py file.
3 - Define your data models in models.py and run migrations.
4 - Create a serializers.py file in your app to define how model instances are converted to JSON and back.
5 - Define a ViewSet in views.py to handle API requests and link it to your serializer.
6 - Configure URL routing, typically using a router.register() call in your project's urls.py file to automatically map the ViewSet actions to URL endpoints. 
===============================================================================================================
GET - Read - Show all books / Show book 10
POST - Create - Add new book
PUT - Update (full) - Replace book 10 completely
PATCH - Update (partial) - Change just book’s title
DELETE - Delete - Remove book 10
==================================================================================================================
API View
There are various types of api viewsets 

1 - Function-Based Views with @api_view
Quick and simple for small endpoints.

# views.py
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

@api_view(['GET', 'POST'])
def ping(request):
    if request.method == 'GET':
        return Response({'message': 'pong'})
    elif request.method == 'POST':
        data = request.data
        return Response({'received': data}, status=status.HTTP_201_CREATED)
-----------------------------------------------------------------------------------------------
Class-Based Views with APIView
Full control over the request/response cycle. You write HTTP method handlers (get, post, etc.).

# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions

class HelloView(APIView):
    permission_classes = [permissions.AllowAny]  # or IsAuthenticated

    def get(self, request):
        user = request.user if request.user.is_authenticated else 'anonymous'
        return Response({'hello': str(user)})

    def post(self, request):
        payload = request.data
        return Response({'you_sent': payload}, status=status.HTTP_201_CREATED)
------------------------------------------------------------------------------------------------

Generic Class-Based Views (ListCreateAPIView, RetrieveUpdateDestroyAPIView, etc.)
Faster CRUD with common behaviors built in.

# serializers.py
from rest_framework import serializers
from .models import Book

class BookSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'


# views.py
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status, permissions
from django.shortcuts import get_object_or_404
from .models import Book
from .serializers import BookSerializer

class BookListCreate(APIView):
    permission_classes = [permissions.IsAuthenticated]  # example
    # You can also set authentication_classes, throttle_classes, parser_classes, renderer_classes

    def get(self, request):
        qs = Book.objects.all()
        serializer = BookSerializer(qs, many=True)
        return Response(serializer.data)

    def post(self, request):
        serializer = BookSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

class BookDetail(APIView):
    permission_classes = [permissions.IsAuthenticated]

    def get(self, request, pk):
        book = get_object_or_404(Book, pk=pk)
        serializer = BookSerializer(book)
        return Response(serializer.data)

    def put(self, request, pk):  # full update
        book = get_object_or_404(Book, pk=pk)
        serializer = BookSerializer(book, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def patch(self, request, pk):  # partial update
        book = get_object_or_404(Book, pk=pk)
        serializer = BookSerializer(book, data=request.data, partial=True)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

    def delete(self, request, pk):
        book = get_object_or_404(Book, pk=pk)
        book.delete()
        return Response(status=status.HTTP_204_NO_CONTENT)
``
-----------------------------------------------------------------------------------------
Doing the CRUD with Generic(less Code)

from rest_framework import generics, permissions
from .models import Book
from .serializers import BookSerializer

class BookListCreateGeneric(generics.ListCreateAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [permissions.IsAuthenticated]

class BookDetailGeneric(generics.RetrieveUpdateDestroyAPIView):
    queryset = Book.objects.all()
    serializer_class = BookSerializer
    permission_classes = [permissions.IsAuthenticated]
``
======================================================================================================
Model Serializer 
ModelSerializer is a shortcut class that automatically creates a serializer based on a Django model.
✅ Auto-generates fields from your model
✅ Built-in validation based on model field types, unique, max_length, blank, etc.
✅ Auto-implements create() and update() (you can override)
✅ Supports nested serializers, validators, read-only/write-only fields, and relationships

we can apply validations in model serializers
class BookSerializer(serializers.ModelSerializer):

    class Meta:
        model = Book
        fields = ['id', 'title', 'title_upper', 'author', 'published']

    def get_title_upper(self, obj):
        return obj.title.upper()
=======================================================================================================
Q - How to serialize the forigne key data in DRF????

1 - Depth keyword 
is used in serializers where we want to show the value of the secound model 
which is connected using the forign Key

2 - Another serializer
or we can get the data of secound serializer using another serializer and using in another serializer

class ColorSerializer(serializers.ModelSerializer):
 Class Meta:
  model = Color
  field = ['color_name']

class
PeopleSerializer(serializers.ModelSerializer):
 color = ColorSerializer (many = True)
 class Meta:
  model = Person
  fields = '_all_'
  # depth = 1
-------------------------------------------------------------------------------
we got full control while using secound serializer, 
wahile in depth we got all the fields of the secound serializer
-----------------------------------------------------------------------------------
